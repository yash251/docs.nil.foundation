# Key components and tools

## zkLLVM Components

The architecture of zkLLVM is modular and extendable. It can be divided into two main components.

### Frontends

Frontends parse high-level languages, generate abstract syntax trees (ASTs), and output intermediate representations (IRs) of circuits. Presently, zkLLVM supports C++ and Rust as frontends based on `clang` and `rustc`, respectively.

`clang` is taken from [**`circifier`**](https://github.com/NilFoundation/zkllvm-circifier), which is an extended fork of the original LLVM project. In turn, `rustc` is contained within [**`rslang`**](https://github.com/NilFoundation/zkllvm-rslang), which is a similarly extended version of the main source code repository for Rust.

As a result, in comparison to the vanilla LLVM project frontends, zkLLVM frontends generate IRs that are extended with custom types and instructions.

### Assigner

`assigner` transforms an IR into two products.

- The assignment table
- Arithmetization-specific constraints

:::info

Constraints flatten a computation into an arithmetization (e.g., R1CS or PLONK). An arithmetization is a set of constraints imposed by a proof system input type.

It is only necessary to generate constraints once per every circuit/input type pair. In contrast, the assignment table needs to be regenerated whenever dynamic inputs change.

:::

Together, these products ensure that the circuit can be proven with dynamic inputs.

<details>
<summary>
Click here to learn more about assigner extendibility
</summary>
<p>
The core of <code>assigner</code> is an LLVM IR parser, which can be ported into any programming language. To access its current implementation, [**click here**](https://github.com/NilFoundation/zkllvm-assigner). This implementation is written in C++ and supports only the PLONK arithmetization.
</p>
<p>
<code>assigner</code> can be extended to support any other arithmetization. This process involves implementing the LLVM IR parser and following these steps.
<ul>
<li>Find a suitable components library for the chosen arithmetization (such as <strong><a href="https://github.com/zcash/halo2">halo2</a></strong> for Rust)</li>
<li>Use the components library to implement assignment table generation</li>
<li>Use the components library to implement constraints generation and serialization</li>
</ul>
</p>
<p>
Note that the zkLLVM frontends output IRs that are modified compared to the IRs generated by the vanilla LLVM project. As a result, any external tool that uses the original <code>LLVMIRParser</code> from LLVM will be unable to parse IRs from zkLLVM.
</p>
<p>
When extending <code>assigner</code>, simply reusing an external parser will not work: it will need to be adapted to fully parse the modified IRs supplied by frontends.
</p> 
</details>


## Proof system components

There are two additional components provided by a proof system rather than zkLLVM.

- A prover used for generating circuit-specific proofs
- A verifier used for verifying circuit-specific proofs

By default, zkLLVM uses the circuit components from [**the blueprint module**](https://github.com/NilFoundation/zkllvm-blueprint) and the PLONKish arithmetization supported by [**the Placeholder proof system**](https://nil.foundation/blog/post/placeholder-proofsystem).

To adapt zkLLVM to other arithmetizations and proof systems, extend the `assigner` component as described above.

:::info[Verifier]

Depending on the proof system, a verifier can be located either on-chain or off-chain.

:::

:::info[Proof systems and arithmetizations]

Note that the same arithmetization can be used by several different proof systems. As a result, constraints generated by `assigner` for one arithmetization can be freely reused across various proof systems.

:::
